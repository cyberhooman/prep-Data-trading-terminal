const express = require('express');
const https = require('https');
const { URL } = require('url');
const fs = require('fs');
const path = require('path');

const PORT = process.env.PORT || 3000;
const FA_ECON_CAL_URL = 'https://nfs.faireconomy.media/ff_calendar_thisweek.json';
const MARKETMILK_API = 'https://marketmilk.babypips.com/api';
const FOREX_LIST_ID = 'fxcm:forex';
const DEFAULT_PERIOD = 'ONE_DAY';
const DEFAULT_STREAM = 'REAL_TIME';
const CALENDAR_CACHE_TTL = 60 * 60 * 1000 + 30 * 1000; // roughly one hour between refreshes
const CALENDAR_RATE_LIMIT_DELAY = 5 * 60 * 1000; // wait 5 minutes after a 429 before retrying

const calendarCache = {
  timestamp: 0,
  records: null,
  nextAllowed: 0,
};

// Simple on-disk persistence for todos, journal and manual events so data survives restarts.
const DATA_DIR = path.join(__dirname, 'data');

function ensureDataDir() {
  try {
    if (!fs.existsSync(DATA_DIR)) fs.mkdirSync(DATA_DIR, { recursive: true });
  } catch (err) {
    console.error('Failed to ensure data directory', DATA_DIR, err);
  }
}

function loadJson(filename, fallback) {
  try {
    const filePath = path.join(DATA_DIR, filename);
    if (fs.existsSync(filePath)) {
      const raw = fs.readFileSync(filePath, 'utf8');
      return JSON.parse(raw || 'null') || fallback;
    }
  } catch (err) {
    console.error('Failed to load', filename, err);
  }
  return fallback;
}

function saveJson(filename, data) {
  try {
    const filePath = path.join(DATA_DIR, filename);
    fs.writeFileSync(filePath, JSON.stringify(data, null, 2), 'utf8');
  } catch (err) {
    console.error('Failed to save', filename, err);
  }
}

function fetchJson(url, options = {}) {
  const { method = 'GET', headers = {}, body } = options;
  return new Promise((resolve, reject) => {
    const urlObj = new URL(url);
    const requestOptions = {
      method,
      headers,
      hostname: urlObj.hostname,
      path: urlObj.pathname + urlObj.search,
      port: urlObj.port || 443,
    };

    const req = https.request(requestOptions, (res) => {
      const chunks = [];
      res.on('data', (chunk) => chunks.push(chunk));
      res.on('end', () => {
        const raw = Buffer.concat(chunks).toString('utf8');
        if (res.statusCode && res.statusCode >= 400) {
          return reject(new Error(`Request failed (${res.statusCode}): ${raw}`));
        }
        try {
          resolve(JSON.parse(raw));
        } catch (err) {
          reject(new Error(`Failed to parse JSON: ${err.message}\nResponse: ${raw}`));
        }
      });
    });

    req.on('error', reject);
    if (body) {
      req.write(body);
    }
    req.end();
  });
}

function convertCalendarRecords(records) {
  if (!Array.isArray(records)) {
    console.warn('Invalid records format:', records);
    return [];
  }
  
  return records
    .filter((item) => {
      if (!item || typeof item !== 'object') {
        console.warn('Invalid calendar item:', item);
        return false;
      }
      return item.impact === 'High';
    })
    .map((item) => {
      if (!item.date) {
        console.warn('Missing date for event:', item);
        return null;
      }
      const eventDate = new Date(item.date);
      if (isNaN(eventDate.getTime())) {
        console.warn('Invalid date for event:', item);
        return null;
      }
      return {
        id: `auto-${item.date}-${item.title}`,
        title: item.title,
        country: item.country,
        impact: item.impact,
        date: eventDate.toISOString(),
        source: 'auto'
      };
    })
    .filter(item => item !== null)
    .filter(item => new Date(item.date).getTime() > Date.now())
    .sort((a, b) => new Date(a.date) - new Date(b.date));
}

async function loadHighImpactEvents() {
  const now = Date.now();

  try {
    console.log('Fetching calendar data...');
    const data = await fetchJson(FA_ECON_CAL_URL, {
      headers: {
        'User-Agent': 'MarketCountdownWeb/1.0',
        'Accept': 'application/json',
      }
    });
    
    if (!Array.isArray(data)) {
      console.error('Invalid calendar data format:', data);
      return [];
    }

    // Update cache
    calendarCache.records = data;
    calendarCache.timestamp = now;
    calendarCache.nextAllowed = now + CALENDAR_CACHE_TTL;

    return convertCalendarRecords(data);
  } catch (err) {
    console.error('Calendar fetch error:', err);
    if (Array.isArray(calendarCache.records)) {
      console.log('Using cached records');
      return convertCalendarRecords(calendarCache.records);
    }
    return [];
  }
}

async function loadCurrencyStrength() {
  try {
    const data = await fetchJson(MARKETMILK_API, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
      body: JSON.stringify({
        query: `query ($listId: ID!, $period: TimelinePeriod!, $streamId: StreamId!) {
          watchlistAnalytics(listId: $listId, period: $period, streamId: $streamId) {
            strength { values { symbolId value } }
          }
        }`,
        variables: {
          listId: FOREX_LIST_ID,
          period: DEFAULT_PERIOD,
          streamId: DEFAULT_STREAM,
        },
      }),
    });

    if (
      !data?.data?.watchlistAnalytics?.strength?.values ||
      !Array.isArray(data.data.watchlistAnalytics.strength.values)
    ) {
      throw new Error('Unexpected response structure');
    }

    return data.data.watchlistAnalytics.strength.values
      .map(({ symbolId, value }) => ({
        id: symbolId,
        name: symbolId.split(':')[1].toUpperCase(),
        title: symbolId.split(':')[1].toUpperCase(),
        value: value * 100,
      }))
      .sort((a, b) => b.value - a.value);
  } catch (err) {
    console.error('Failed to load currency strength:', err);
    throw err;
  }
}

function escapeHtml(str) {
  return String(str)
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&#39;');
}

function formatEventDate(date) {
  return date.toLocaleString(undefined, {
    weekday: 'short',
    month: 'short',
    day: 'numeric',
    hour: '2-digit',
    minute: '2-digit',
    timeZoneName: 'short',
  });
}

ensureDataDir();

let manualEvents = loadJson('events.json', []).map(event => ({
  ...event,
  date: new Date(event.date).toISOString()
}));

const todoItems = loadJson('todos.json', []);
const journalEntries = loadJson('journal.json', []);

function getUpcomingEvents() {
  const now = Date.now();
  return manualEvents
    .filter((event) => {
      try {
        const eventDate = new Date(event.date);
        return !isNaN(eventDate.getTime()) && eventDate.getTime() > now;
      } catch (e) {
        console.error('Invalid date in event:', event);
        return false;
      }
    })
    .map((event) => ({
      id: event.id,
      title: event.title,
      country: event.country,
      date: event.date,
      source: 'manual'
    }))
    .sort((a, b) => new Date(a.date) - new Date(b.date));
}

async function gatherEvents() {
  console.log('Gathering events...');
  const manualUpcoming = getUpcomingEvents() || [];
  console.log('Manual events:', manualUpcoming);
  
  let autoEvents = [];
  let autoError = null;
  
  try {
    const loadedEvents = await loadHighImpactEvents();
    autoEvents = Array.isArray(loadedEvents) ? loadedEvents : [];
    console.log('Auto events loaded:', autoEvents);
  } catch (err) {
    console.error('Error loading auto events:', err);
    autoError = err.message.replace(/<[^>]+>/g, '').trim();
    autoEvents = [];
  }

  // Ensure both arrays are valid before combining
  const validManual = Array.isArray(manualUpcoming) ? manualUpcoming : [];
  const validAuto = Array.isArray(autoEvents) ? autoEvents : [];
  
  const combinedEvents = [...validManual, ...validAuto].sort((a, b) => {
    const dateA = new Date(a.date);
    const dateB = new Date(b.date);
    return dateA.getTime() - dateB.getTime();
  });
  
  return { manualUpcoming, autoEvents, combinedEvents, autoError };
}

const app = express();
app.use(express.urlencoded({ extended: true }));

app.get('/', async (req, res) => {
  let strengthData = [];
  let manualUpcoming = [];
  let autoEvents = [];
  let combinedEvents = [];
  let errorMsg = '';
  const message = req.query.message ? String(req.query.message) : '';

  try {
    strengthData = await loadCurrencyStrength().catch((err) => {
      errorMsg = `Currency strength error: ${err.message}`;
      return [];
    });
    const { manualUpcoming: manualList, autoEvents: autoList, combinedEvents: combined, autoError } =
      await gatherEvents();
    manualUpcoming = manualList;
    autoEvents = autoList;
    combinedEvents = combined;
    if (autoError) {
      errorMsg = errorMsg ? `${errorMsg}; ${autoError}` : autoError;
    }
  } catch (err) {
    errorMsg = err.message;
  }

  const eventsJson = JSON.stringify(
    combinedEvents.map((event) => {
      const eventDate = new Date(event.date);
      return {
        id: event.id,
        title: event.title,
        country: event.country,
        timestamp: eventDate.getTime(),
        formatted: formatEventDate(eventDate),
        source: event.source,
      };
    })
  );
  const nextEvent = combinedEvents[0] || null;
  const nextEventJson = JSON.stringify(
    nextEvent ? {
      id: nextEvent.id,
      title: nextEvent.title,
      country: nextEvent.country,
      timestamp: new Date(nextEvent.date).getTime(),
      formatted: formatEventDate(new Date(nextEvent.date)),
      source: nextEvent.source,
    } : null
  );

  const nextEventPanel = nextEvent
    ? `
      <div class="next-event-card">
        <div class="next-event-title">
          [${escapeHtml(nextEvent.country)}] ${escapeHtml(nextEvent.title)}
          <span class="badge ${nextEvent.source === 'manual' ? 'manual' : 'auto'}">
            ${nextEvent.source === 'manual' ? 'Manual' : 'Auto'}
          </span>
        </div>
        <div class="next-event-meta">Scheduled: ${formatEventDate(new Date(nextEvent.date))}</div>
        <div class="countdown next-countdown" id="next-event-countdown">Loading...</div>
      </div>
    `
    : '<p class="next-empty">No upcoming events yet. Use the form below to add one.</p>';
    
  // Rest of your app.get('/') handler...